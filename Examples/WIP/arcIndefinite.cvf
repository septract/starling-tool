/* Atomic reference counter encoded with integers.
 * Example taken from Derek: http://www.mpi-sws.org/~dreyer/talks/talk-dagstuhl16.pdf
 */

shared int free, count;
thread int f, c;

method init() {
  {| noArc() |}
    <{ free = 0; count = 1; }>;
  {| arc() |}
}

// Assumption: clone() cannot be called when there are no references
method clone() {
  {| arc() |} < count++ >; {| arc() * arc() |}
}

// Try to prove that print() when holding a reference is always valid
// i.e. free can never be true when {| arc() |} is held
method print() {
  {| arc() |}
    <f = free>;
  {| arc() * freeVal(f) |}
    // Test for disposal
    if (f != 0) {
      {| error() |} ; {| error() |}
    }
  {| arc() |}
}

method drop() {
  {| arc() |}
    < c = count-- >;
  {| countVal(c) |}
    if (c == 1) {
      {| freeing() |}
        <free = 1>;
      {| emp |}
    }
  {| emp |}
}

view error();
view iter[n] arc();
view freeing();
view noArc();

// These views just add free=f and count=c to the final proof predicates
view countVal(int c);
view freeVal(int f);


constraint emp -> 0 <= count;
constraint freeing() -> count == 0;

constraint noArc() -> count == 0 && free == 1;
// noArc has to have exclusivity over threads.
exclusive noArc(), noArc();
exclusive noArc(), freeing();
exclusive noArc(), freeVal(f);
exclusive noArc(), countVal(f);

constraint countVal(c) -> ?;

// freeVal(f) * arc() -> f = free;
constraint freeVal(f) -> ?;

// holds less than count arc()'s
//  and if holding at least 1 then it can't have been freed
constraint iter[n] arc() -> n <= count
                            && (n > 0 => (free == 0));

// goal
constraint error() -> false;
