/// The Starling-language frontend driver.
module Starling.Lang.Frontend

open Chessie.ErrorHandling
open Starling
open Starling.Model
open Starling.Pretty.Misc

(*
 * Request and response types
 *)

/// Type of requests to the Starling frontend.
type Request = 
    /// Only parse a Starling script; return `Output.Parse`.
    | Parse
    /// Parse and collate a Starling script; return `Output.Collation`.
    | Collate
    /// Parse, collate, and model a Starling script.
    | Model

/// Type of responses from the Starling frontend.
type Response =
    /// Output of the parsing step only. 
    | Parse of AST.ScriptItem list
    /// Output of the parsing and collation steps.
    | Collate of Collator.CollatedScript
    /// Output of the parsing, collation, and modelling steps.
    | Model of Model<PartAxiom>

(*
 * Error types
 *)

/// Type of errors generated by the Starling frontend.
type Error = 
    /// A parse error occurred, details of which are enclosed in string form.
    | Parse of string
    /// A modeller error occurred, given as a `ModelError`.
    | Model of Errors.Lang.Modeller.ModelError

(*
 * Pretty-printing
 *)

/// Pretty-prints a response.
let printResponse = 
    function 
    | Response.Parse s -> Pretty.Lang.AST.printScript s
    | Response.Collate c -> printCollatedScript c
    | Response.Model m -> printModel printPartAxiom m

/// Pretty-prints an error.
let printError =
    function
    | Error.Parse e -> Pretty.Types.String e
    | Error.Model e -> Pretty.Errors.printModelError e

(*
 * Driver functions
 *)

/// Shorthand for the parser stage of the frontend pipeline.
let parse = Parser.parseFile >> mapMessages Error.Parse
/// Shorthand for the collation stage of the frontend pipeline.
let collate = lift Collator.collate
/// Shorthand for the modelling stage of the frontend pipeline.
let model = bind (Modeller.model >> mapMessages Error.Model) 

/// Runs the Starling frontend.
/// Takes two arguments: the first is the `Response` telling the frontend what
/// to output; the second is an optional filename from which the frontend
/// should read (if empty, read from stdin).
let run =
    function
    | Request.Parse -> parse >> lift Response.Parse
    | Request.Collate -> parse >> collate >> lift Response.Collate
    | Request.Model -> parse >> collate >> model >> lift Response.Model
